/*
 * @(#)Broken11ClassFixer.java	1.8 10/03/24
 *
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */
 
/** <P> This is a special-purpose class file parser and patcher which
    repairs class files (typically generated by old 1.1-era compilers)
    with the following three format errors: </P>
    
    <P>

    <UL>
    <LI> Extra bytes at the end of the class file
    <LI> Local variable name has bad constant pool index
    <LI> Local variable table entry has bad start PC/length
    </UL>

    </P>
    <P>

    It also fixes the following error from 1.0-era compilers:
    
    </P>
    <P>

    <UL>
    <LI> Both JVM_ACC_PRIVATE and JVM_ACC_PROTECTED set for
         fields/methods
    </UL>
    </P>
    <P>

    Intended usage (in a subclass of ClassLoader):

    <PRE>
    try {
      defineClass(name, bytes, off, len);
    } catch (ClassFormatError cfe) {
      try {
        Broken11ClassFixer fixer = new Broken11ClassFixer();
        fixer.process(bytes, off, len);
        defineClass(name,
                    fixer.getProcessedData(),
                    fixer.getProcessedDataOffset(),
                    fixer.getProcessedDataLength());
      } catch (Exception e) {
        // No good. Throw the original exception.
        throw(cfe);
      }
    } 
    </PRE>

    </P> */

package sun.plugin.security;

import java.lang.reflect.*;
import java.io.*;

public class Broken11ClassFixer {

  public Broken11ClassFixer() {}

  /** Caller must expect arbitrary exceptions to be thrown from this
      code and assume that if an exception is thrown that the class
      file is broken beyond repair. The given class file does not
      necessarily have to exhibit the format errors this routine is
      designed to fix. */
  public void process(byte[] data, int off, int len) throws Exception {
    init(data, off, len);
    copyHeader();
    scanAndCopyConstantPool();
    copyAccessFlagsAndClassInformation();
    copyInterfaces();
    scanAndCopyFields();
    scanAndCopyMethods();
    copyAttributes();
  }

  /** Returns the processed data to feed to ClassLoader.defineClass().
      Call this only if process() did not throw an exception. */
  public byte[] getProcessedData() { return dest; }

  /** Returns the offset in the processed data to feed to
      ClassLoader.defineClass(). Call this only if process() did not
      throw an exception. */
  public int getProcessedDataOffset() { return 0; }

  /** Returns the length of the processed data to feed to
      ClassLoader.defineClass(). Call this only if process() did not
      throw an exception. */
  public int getProcessedDataLength() { return destPos; }

  //----------------------------------------------------------------------
  // Internals only below this point
  //
  private byte[]   src;
  private int      srcPos;
  private byte[]   dest;
  private int      destPos;
  private int      numConstantPoolEntries;

  // Only used by test harness
  private boolean  detectedBogusLocalVariableNameIndex;

  // Indexed by constant pool index - 1. Marks whether the constant
  // pool entry was the Utf8 string "Code" or "LocalVariableTable".
  private static final int CODE_MASK                 = 0x1;
  private static final int LOCAL_VARIABLE_TABLE_MASK = 0x2;
  private byte[]   constantPoolUtf8Entries;

  private void init(byte[] bytes, int off, int len) {
    src = bytes;
    srcPos = off;
    dest = new byte[len];
    destPos = 0;
    detectedBogusLocalVariableNameIndex = false;
  }

  //
  //
  // Reader/writer routines
  //
  //

  private int srcPos() { return srcPos; }
  private int destPos() { return destPos; }

  // Reading routines (advance srcPos, do not advance destPos)
  private int readByte() {
    return src[srcPos++] & 0xFF;
  }

  private int readShort() {
    int hi = readByte();
    int lo = readByte();
    return (hi << 8) | lo;
  }

  private int readInt() {
    int hi = readShort();
    int lo = readShort();
    return (hi << 16) | lo;
  }

  // Writing routines (advance destPos, do not advance srcPos)
  private void writeByte(int val) {
    dest[destPos++] = (byte) val;
  }

  private void writeShort(int val) {
    writeByte(val >> 8);
    writeByte(val);
  }

  private void writeInt(int val) {
    writeShort(val >> 16);
    writeShort(val);
  }

  // Mutation routines for dest (do not advance)
  private void writeByteAt(int pos, int val) {
    dest[pos] = (byte) val;
  }

  private void writeShortAt(int pos, int val) {
    writeByteAt(pos, val >> 8);
    writeByteAt(pos + 1, val);
  }

  private void writeIntAt(int pos, int val) {
    writeShortAt(pos, val >> 16);
    writeShortAt(pos + 2, val);
  }

  // Copying routines (advance both srcPos and destPos)
  private void copy(int numBytes) {
    for (int i = 0; i < numBytes; i++) {
      dest[destPos + i] = src[srcPos + i];
    }
    srcPos += numBytes;
    destPos += numBytes;
  }

  private int copyByte() {
    int val = readByte();
    writeByte(val);
    return val;
  }

  private int copyShort() {
    int val = readShort();
    writeShort(val);
    return val;
  }

  private int copyInt() {
    int val = readInt();
    writeInt(val);
    return val;
  }

  private void copyHeader() {
    copy(8); // magic, minor_version, major_version
  }

  private static final int CONSTANT_CLASS_TAG = 7;
  private static final int CONSTANT_FIELD_REF_TAG = 9;
  private static final int CONSTANT_METHOD_REF_TAG = 10;
  private static final int CONSTANT_INTERFACE_METHOD_REF_TAG = 11;
  private static final int CONSTANT_STRING_TAG = 8;
  private static final int CONSTANT_INTEGER_TAG = 3;
  private static final int CONSTANT_FLOAT_TAG = 4;
  private static final int CONSTANT_LONG_TAG = 5;
  private static final int CONSTANT_DOUBLE_TAG = 6;
  private static final int CONSTANT_NAME_AND_TYPE_TAG = 12;
  private static final int CONSTANT_UTF8_TAG = 1;

  private void scanAndCopyConstantPool() {
    numConstantPoolEntries = copyShort() - 1;
    constantPoolUtf8Entries = new byte[numConstantPoolEntries];
    for (int i = 0; i < numConstantPoolEntries; i++) {
      int tag = copyByte();
      switch (tag) {
      case CONSTANT_CLASS_TAG:
      case CONSTANT_STRING_TAG:
        // 2 bytes of extra info
        copy(2);
        break;

      case CONSTANT_FIELD_REF_TAG:
      case CONSTANT_METHOD_REF_TAG:
      case CONSTANT_INTERFACE_METHOD_REF_TAG:
      case CONSTANT_INTEGER_TAG:
      case CONSTANT_FLOAT_TAG:
      case CONSTANT_NAME_AND_TYPE_TAG:
        // 4 bytes of extra info
        copy(4);
        break;

      case CONSTANT_LONG_TAG:
      case CONSTANT_DOUBLE_TAG:
        // 8 bytes of extra info
        copy(8);
        i++; // 8-byte constants take two "slots" in the constant pool.
             // "In retrospect, making 8-byte constants take two
             // constant pool entries was a poor choice."
        break;

      case CONSTANT_UTF8_TAG:
        // Variable length extra info
        scanAndCopyUtf8(i);
        break;

      default:
        throw new RuntimeException("Invalid constant pool tag " + tag);
      }
    }
  }

  private void scanAndCopyUtf8(int zeroBasedCPIdx) {
    int utf8Length = copyShort();
    String code = "Code";
    String localVariableTable = "LocalVariableTable";

    if (utf8Length == code.length()) {
      if (copyUtf8LookingFor(code)) {
        markCodeInCP(zeroBasedCPIdx);
      }
    } else if (utf8Length == localVariableTable.length()) {
      if (copyUtf8LookingFor(localVariableTable)) {
        markLocalVariableTableInCP(zeroBasedCPIdx);
      }
    } else {
      copy(utf8Length);
    }
  }

  private boolean copyUtf8LookingFor(String targetToLookFor) {
    int len = targetToLookFor.length();
    for (int i = 0; i < len; i++) {
      int val = copyByte();
      if (val != (targetToLookFor.charAt(i) & 0xFF)) {
        // Copy rest of string and return
        copy(len - i - 1);
        return false;
      }
    }
    return true;
  }

  private void markCodeInCP(int zeroBasedCPIdx) {
    constantPoolUtf8Entries[zeroBasedCPIdx] |= CODE_MASK;
  }

  private void markLocalVariableTableInCP(int zeroBasedCPIdx) {
    constantPoolUtf8Entries[zeroBasedCPIdx] |= LOCAL_VARIABLE_TABLE_MASK;
  }

  private void copyAccessFlagsAndClassInformation() {
    copy(6); // access_flags, this_class, super_class
  }

  private void copyInterfaces() {
    int num = copyShort();
    copy(2 * num);
  }

  private void scanAndCopyFields() {
    int num = copyShort();
    for (int i = 0; i < num; i++) {
      scanAndCopyAccessFlags();
      copy(4); // name_index, descriptor_index
      copyAttributes();
    }
  }

  private void scanAndCopyAccessFlags() {
    int val = readShort();

    // Fix methods/fields from 1.0.x compilers with public, private and
    // protected bits set
   
    if (Modifier.isPublic(val))
    {
	val = val & ~(Modifier.PROTECTED | Modifier.PRIVATE);
    }
    else if (Modifier.isProtected(val))
    {
	val = val & ~(Modifier.PUBLIC | Modifier.PRIVATE);
    }
    else
    {
	val = val & ~(Modifier.PUBLIC | Modifier.PROTECTED);
    }


    // If method has its ACC_ABSTRACT flag set it may not have any of its
    // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC, ACC_STRICT, or
    // ACC_SYNCHRONIZED flags set (Java Language specs 2.13.3.2)
    //
    if (Modifier.isAbstract(val))
    {
	val = val & ~(Modifier.PRIVATE | Modifier.FINAL | Modifier.NATIVE | Modifier.SYNCHRONIZED | Modifier.STATIC | Modifier.STRICT);
    }

    writeShort(val);
  }

/*
  private static final int JVM_ACC_PRIVATE   = 0x2;
  private static final int JVM_ACC_PROTECTED = 0x4;
  private static final int PRIV_PROT_MASK    = (JVM_ACC_PRIVATE | JVM_ACC_PROTECTED);
  private static final int CLEAR_PRIV_MASK   = (~JVM_ACC_PRIVATE);

  private void scanAndCopyAccessFlags() {
    int val = readShort();

    // Fix methods/fields from 1.0.x compilers with both private and
    // protected bits set
    if ((val & PRIV_PROT_MASK) == PRIV_PROT_MASK) {
      // Convert these to protected (remove private bit)
      val = val & CLEAR_PRIV_MASK;
    }
    writeShort(val);
  }
*/
  // This convenience routine tests to see whether the given constant
  // pool index (one-based, i.e., read from the class file) is the
  // string "LocalVariableTable"
  private boolean cpIdxIsLocalVariableTable(int cpIdx) {
    return ((constantPoolUtf8Entries[cpIdx - 1] & LOCAL_VARIABLE_TABLE_MASK) != 0);
  }

  // This convenience routine tests to see whether the given constant
  // pool index (one-based, i.e., read from the class file) is the
  // string "Code"
  private boolean cpIdxIsCode(int cpIdx) {
    return ((constantPoolUtf8Entries[cpIdx - 1] & CODE_MASK) != 0);
  }

  // This convenience routine tests to see whether the given constant
  // pool index is valid
  private boolean isValidConstantPoolIndex(int cpIdx) {
    return (cpIdx > 0 && cpIdx <= numConstantPoolEntries);
  }

  private boolean isValidStartAndLength(int startPC, int length, int codeLength) {
    return ((startPC >= 0) && ((startPC + length) <= codeLength));
  }

  private void copyAttributes() {
    int numAttr = copyShort();
    for (int i = 0; i < numAttr; i++) {
      copyAttribute();
    }
  }

  private void copyAttribute() {
    copy(2);
    copyRestOfAttribute();
  }

  private void copyRestOfAttribute() {
    copy(copyInt());
  }

  // This is where most of the work gets done. We need to look for the
  // "LocalVariableTable" attributes inside the "Code" attributes of
  // all methods and look for entries which have an invalid constant
  // pool index for their name. (May end up looking for other defects
  // after testing.) These entries will be removed from the
  // LocalVariableTables.
  private void scanAndCopyMethods() {
    int numMethods = copyShort();
    for (int i = 0; i < numMethods; i++) {
      scanAndCopyAccessFlags();
      copy(4); // name_index, descriptor_index
      int numAttributes = copyShort();
      for (int j = 0; j < numAttributes; j++) {
        // Look for "Code" attribute.
        int attrNameIdx = copyShort();
        if (cpIdxIsCode(attrNameIdx)) {
          processCodeAttribute();
        } else {
          copyRestOfAttribute();
        }
      }
    }
  }

  // Have already copied the attribute's name index by the time we
  // enter here
  private void processCodeAttribute() {
    int codeAttributeLengthPos = destPos();
    int codeAttributeLength    = copyInt();
    copy(4); // max_stack, max_locals
    int codeLength = copyInt(); // code_length
    copy(codeLength); // code
    copy(8 * copyShort()); // exception_table_length, exception_table
    int numAttr = copyShort();
    for (int i = 0; i < numAttr; i++) {
      // Look for "LocalVariableTable" attribute.
      int attrNameIdx = copyShort();
      if (cpIdxIsLocalVariableTable(attrNameIdx)) {
        processLocalVariableTableAttribute(codeAttributeLengthPos, codeAttributeLength, codeLength);
      } else {
        copyRestOfAttribute();
      }
    }
  }

  // Have already copied the attribute's name index by the time we
  // enter here
  private void processLocalVariableTableAttribute(int codeAttributeLengthPos,
                                                  int codeAttributeLength,
                                                  int codeLength) {
    // The items potentially needing fixup are the attribute_length
    // and local_variable_table_length.
    int attributeLengthPos          = destPos();
    int attributeLength             = copyInt();
    int localVariableTableLengthPos = destPos();
    int localVariableTableLength    = copyShort();

    int newLocalVariableTableLength = localVariableTableLength;

    final int LOCAL_VARIABLE_TABLE_ENTRY_SIZE = 10;

    for (int i = 0; i < localVariableTableLength; i++) {
      // Read all information for this entry (without writing)
      int startPC         = readShort();
      int length          = readShort();
      int nameIndex       = readShort();
      int descriptorIndex = readShort();
      int index           = readShort();

      // Check name index and start PC and length
      // (could put other checks here as well)
      if (isValidConstantPoolIndex(nameIndex) &&
          isValidStartAndLength(startPC, length, codeLength)) {
        // Write all data
        writeShort(startPC);
        writeShort(length);
        writeShort(nameIndex);
        writeShort(descriptorIndex);
        writeShort(index);
      } else {
        // Eliminate this entry. Backpatch the attribute length and
        // local variable table length.
        codeAttributeLength -= LOCAL_VARIABLE_TABLE_ENTRY_SIZE;
        attributeLength     -= LOCAL_VARIABLE_TABLE_ENTRY_SIZE;
        --newLocalVariableTableLength;
        writeIntAt(codeAttributeLengthPos, codeAttributeLength);
        writeIntAt(attributeLengthPos, attributeLength);
        writeShortAt(localVariableTableLengthPos, newLocalVariableTableLength);

        detectedBogusLocalVariableNameIndex = true;
      }
    }
  }

  private static void usage() {
    System.err.println("Usage: java Broken11ClassFixer [filename]");
    System.exit(1);
  }

  // Test harness
  public static void main(String[] args) {
    if (args.length != 1) usage();
    try {
      File file = new File(args[0]);
      int len = (int) file.length();
      byte[] buf = new byte[len];
      BufferedInputStream in = new BufferedInputStream(new FileInputStream(file));
      int pos = 0;
      while (pos < buf.length) {
        pos += in.read(buf, pos, buf.length - pos);
      }
      Broken11ClassFixer fixer = new Broken11ClassFixer();
      fixer.process(buf, 0, buf.length);

      if (fixer.detectedBogusLocalVariableNameIndex) {
        System.err.println("Detected bogus local variable name index");
      }
      if (fixer.srcPos < buf.length) {
        System.err.println("Detected extra bytes at the end of the class file");
      }
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}

