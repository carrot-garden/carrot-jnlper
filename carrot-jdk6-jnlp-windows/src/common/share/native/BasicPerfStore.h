/*
 * @(#)BasicPerfStore.h	1.2 10/03/24
 *
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */
#ifndef _BASIC_PERF_STORE_H_
#define _BASIC_PERF_STORE_H_

#include "jni.h"
#include "NativeLock.h"
#include "NativeLocker.h"
#include "PerfLabel.h"
#include "PerfLib.h"
#include "PerfStore.h"
#include "SystemTime.h"


class PERFLIB_API BasicPerfStore : public PerfStore {

public:
    ////////////////////////////////////////////////////////////////////////////
    // Puts a time stamped label entry in the local storage buffer.  The time
    // stamp is automatically generated by this call.
    //
    // Override this method to provide synchronization, plus any required IPC.
    //
    // @param  label  the label to write.
    //
    virtual void put(const char * label) {
        NativeLocker lock(&m_sync);

        if (m_count == MAX_LABEL_COUNT) {
            PerfStore::OutOfBounds exception;

            throw (exception);
        }

        PerfLabel entry(m_clock.getCurrentTime(), label);

        m_labels[m_count++] = entry;
    }


    ////////////////////////////////////////////////////////////////////////////
    // Puts a time stamped label entry in the local storage buffer using a Java
    // string as the source.  The time stamp is automatically generated by this call.
    //
    // @param  pEnv    a pointer to the Java environment that's making the request.
    // @param  jLabel  the label to write.
    //
    void put(JNIEnv * pEnv, jstring jLabel);


    ////////////////////////////////////////////////////////////////////////////
    // Gets the number of labels currently stored.
    //
    // @return the number of labels currently stored.
    //
    virtual size_t size(void) const { return (m_count); }


    ////////////////////////////////////////////////////////////////////////////
    // Gets the label at the given index.
    //
    // @return the label at the given index.
    //
    // @throw OutOfBounds if the index is out of bounds.
    //
    virtual PerfLabel get(size_t index) const {
        PerfLabel result;

        // need to cheat to get non-const access to the lock
        BasicPerfStore * thisun = const_cast<BasicPerfStore *>(this);
        NativeLocker     lock(&(thisun->m_sync));

        result = _get(index);

        return (result);
    }


    ////////////////////////////////////////////////////////////////////////////
    // Gets the contents of the label storage as an array of Java objects.
    //
    // This is a helper function for converting the local native PerfLabel
    // storage into a Java array.
    //
    // @param  pEnv  a pointer to the Java environment that's making the request.
    //
    // @returns the contents of the label storage as an array of Java objects.
    //
    jobjectArray toArray(JNIEnv * pEnv) const;


    BasicPerfStore(const SystemTime & clock,
                   NativeLock       & sync)
            : m_clock(clock),
              m_sync(sync),
              m_count(0) {
        // everything done in init
    }


private:
    ////////////////////////////////////////////////////////////////////////////
    // Gets the label at the given index without acquiring the sync object first.
    //
    // @return the label at the given index.
    //
    // @throw OutOfBounds if the index is out of bounds.
    //
    PerfLabel _get(size_t index) const {
        if ((index < 0) || (index >= m_count)) {
            PerfStore::OutOfBounds exception;

            throw (exception);
        }

        return (m_labels[index]);
    }


    static const size_t MAX_LABEL_COUNT = 128;


    const SystemTime & m_clock;
    NativeLock       & m_sync;
    size_t             m_count;
    PerfLabel          m_labels[MAX_LABEL_COUNT];
};

#endif    // _BASIC_PERF_STORE_H_
